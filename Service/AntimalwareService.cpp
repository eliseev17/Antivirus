#include "AntimalwareService.h"
#include <thread>
#include <fstream>

namespace Antimalware::ServiceApp
{
	int AntimalwareService::Init()
	{
		return 0;
	}

	void AntimalwareService::DoWork()
	{
        InformationStorage infoStorage = Database::getInfo("./../AntimalwareDatabase.db");

        // Основной цикл создает экземпляр именованного канала, а затем ждет, пока клиент подключится к нему.
        // Когда клиент подключается, создается поток для обработки взаимодействия с этим клиентом,
        // и этот цикл (который основной) может ждать следующего запроса на подключение клиента. Это бесконечный цикл. 

            //cout << "Main thread waiting for connect on pipe " << "\\\\.\\pipe\\firstPipe" << endl;
            pipeClientToService = CreateNamedPipe(
                firstPipeName,             // имя канала 
                PIPE_ACCESS_DUPLEX,       // чтение/запись доступ 
                PIPE_TYPE_MESSAGE |       // тип сообщения каналу 
                PIPE_READMODE_MESSAGE |   // режим чтения сообщений 
                PIPE_WAIT,                // режим блокирования
                PIPE_UNLIMITED_INSTANCES, // максимальное количество экземпляров 
                PIPE_BUFSIZE,                  // размер буфера на выход 
                PIPE_BUFSIZE,                  // размер буфера на вход 
                0,                        // клиент время 
                NULL);                    // атрибут безопасности по умолчанию 

            if (pipeClientToService == INVALID_HANDLE_VALUE)
            {
                return; //Создание именованного канала не удалось, код ошибки
            }
            // Break if the pipe handle is valid. 
            if (pipeClientToService == INVALID_HANDLE_VALUE)
            {
                CloseHandle(pipeClientToService);
                pipeServiceToClient = NULL;
                return;
            }

            // Exit if an error other than ERROR_PIPE_BUSY occurs.
            if (GetLastError() == ERROR_PIPE_BUSY)
            {
                CloseHandle(pipeClientToService);
                pipeServiceToClient = NULL;
                return;
            }

            if (GetLastError() == ERROR_BROKEN_PIPE)
            {
                CloseHandle(pipeClientToService);
                pipeServiceToClient = NULL;
                return;
            }

            if (GetLastError() == ERROR_FILE_NOT_FOUND)
            {
                CloseHandle(pipeClientToService);
                pipeServiceToClient = NULL;
                return;
            }
            // Подождите, пока клиент подключится; если это удастся,
            // функция возвращает ненулевое значение. Если функция
            // возвращает ноль, GetLastError возвращает ERROR_PIPE_CONNECTED.
            fConnected = ConnectNamedPipe(pipeClientToService, NULL) ?
                TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);

            if (fConnected)
            {
                // Клиент подключён, создаётся поток для него...
                // Создание потока для клиента  
                //cout << "Client connected" << endl;
                std::thread clientThread(&AntimalwareService::clientMessagesProcessing);
                clientThread.detach();
                // Поток создан, получение и обработка сообщений...
            }
            else  // Клиент не смог подключиться, поэтому закрываем канал.
            {
                CloseHandle(pipeClientToService); //Создание потока не удалось, код ошибки
            }
       // }
        return;
	}
	 
	int AntimalwareService::DoStop()
	{
        FlushFileBuffers(pipeClientToService);
        DisconnectNamedPipe(pipeClientToService);
        CloseHandle(pipeClientToService);
        CloseHandle(pipeServiceToClient);

        Database outputInfo = Database("./../AntimalwareDatabase.db", infoStorage);
		return 0;
	}

	AntimalwareServiceFactory::AntimalwareServiceFactory()
	{
	}

	std::unique_ptr<ServiceLib::ServiceManagement::Service> AntimalwareServiceFactory::Create()
	{
		return std::make_unique<AntimalwareService>();
	}

    int AntimalwareService::clientMessagesProcessing()
    {
        // Выполняем дополнительную проверку ошибок, поскольку
        // приложение будет продолжать работать, даже если этот
        // поток выходит из строя.
        if (pipeClientToService == NULL)
        {
            return -1; //InstanceThread got an unexpected NULL value in lpvParam
        }

        pipeServiceToClient = CreateFile(
            secondPipeName,   // pipe name 
            GENERIC_READ |  // read and write access 
            GENERIC_WRITE,
            0,              // no sharing 
            NULL,           // default security attributes
            OPEN_EXISTING,  // opens existing pipe 
            0,              // default attributes 
            NULL);          // no template file 

            // Break if the pipe handle is valid. 
        if (pipeServiceToClient == INVALID_HANDLE_VALUE)
        {
            CloseHandle(pipeServiceToClient);
            pipeServiceToClient = NULL;
            return -1;
        }

        // Exit if an error other than ERROR_PIPE_BUSY occurs.
        if (GetLastError() == ERROR_PIPE_BUSY)
        {
            CloseHandle(pipeServiceToClient);
            pipeServiceToClient = NULL;
            return -1;
        }

        if (GetLastError() == ERROR_BROKEN_PIPE)
        {
            CloseHandle(pipeServiceToClient);
            pipeServiceToClient = NULL;
            return -1;
        }

        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            CloseHandle(pipeServiceToClient);
            pipeServiceToClient = NULL;
            return -1;
        }

        // Thread: Результат работы
        message threatsInfo;
        threatsInfo.cmd = COMMAND::INFO;
        threatsInfo.nArr.push_back(0);
        for (size_t i = 0; i < infoStorage.threatPaths.size(); i++)
        {
            threatsInfo.sArr.push_back(infoStorage.threatPaths.at(i));
            threatsInfo.sArr.push_back(infoStorage.threatNames.at(i));
        }
        Messenger::sendMessage(pipeServiceToClient, PIPE_BUFSIZE, threatsInfo);
        threatsInfo.nArr.clear();
        threatsInfo.sArr.clear();

        threatsInfo.nArr.push_back(1);
        for (size_t i = 0; i < infoStorage.quarPaths.size(); i++)
        {
            threatsInfo.sArr.push_back(infoStorage.quarPaths.at(i));
            threatsInfo.sArr.push_back(infoStorage.quarNames.at(i));
        }
        Messenger::sendMessage(pipeServiceToClient, PIPE_BUFSIZE, threatsInfo);
        threatsInfo.nArr.clear();
        threatsInfo.sArr.clear();


        listenPipe();

        // "Чистим" канал, чтобы клиент мог прочитать его содержимое
        // перед отключением. Затем отключаем канал и закрываем
        // дескриптор этого экземпляра канала.
        FlushFileBuffers(pipeClientToService);
        DisconnectNamedPipe(pipeClientToService);
        CloseHandle(pipeClientToService);
        CloseHandle(pipeServiceToClient);

        Database outputInfo = Database("./../AntimalwareDatabase.db", infoStorage);
        //cout << "Thread поток завершил работу" << endl << endl;
        return 0;
    }

    void AntimalwareService::processingMessage(message newMessage)
    {
        Scanner scanner;
        Monitoring monitoring;
        ScheduledScanner scheduledScanner;
        switch (newMessage.cmd)
        {
        case COMMAND::DEL: {
            FilesWorker::deleteThreat(newMessage, infoStorage);
            break;
        }
        case COMMAND::START: {
            std::string filePath = newMessage.sArr.at(0);
            scanner.startScan(filePath, pipeServiceToClient, infoStorage);
            break;
        }
        case COMMAND::STOP: {
            scanner.stopScan();
            break;
        }
        case COMMAND::MOVE_TO_QUARANTINE: {
            FilesWorker::moveToQuarantine(newMessage, infoStorage);
            break;
        }
        case COMMAND::DELETE_FROM_QUARANTINE: {
            FilesWorker::deleteFromQuarantine(newMessage, infoStorage);
            break;
        }
        case COMMAND::SET_SCHEDULE: {
            scheduledScanner.startScheduledScan(pipeServiceToClient, newMessage, infoStorage);
            break;
        }
        case COMMAND::RESET_SCHEDULE: {
            scheduledScanner.cancelScheduledScan();
            break;
        }
        case COMMAND::SET_MONITORING: {
            std::string monitoringDirectory = newMessage.sArr.at(0);
            monitoring.start(monitoringDirectory, pipeServiceToClient, infoStorage);
            break;
        }
        case COMMAND::STOP_MONITORING: {
            monitoring.stop();
            break;
        }
        case COMMAND::STOP_SERVICE: {
            DoStop();
            ExitProcess(0);
            break;
        }
        }
        //cout << "Thread: Запрос клиента обработан" << endl << endl;
    }

    void AntimalwareService::listenPipe()
    {
        while (GetLastError() != ERROR_BROKEN_PIPE)
        {
            message newMessage = Messenger::readMessage(pipeClientToService, PIPE_BUFSIZE);
            if (newMessage.cmd == COMMAND::UNKNOWN)
            {
                break;
            }
            std::thread scanThread(&AntimalwareService::processingMessage, newMessage);
            scanThread.detach();
        }
    }

}