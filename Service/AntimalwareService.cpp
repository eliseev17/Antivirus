#include "AntimalwareService.h"
#include <thread>
#include <fstream>

namespace Antimalware::ServiceApp
{
	int AntimalwareService::Init()
	{
        infoStorage.reset(new InformationStorage());
        Database::getInfo(DATABASE_PATH, infoStorage);
		return 0;
	}

	void AntimalwareService::DoWork()
	{       
        //infoStorage.reset(new InformationStorage());
        Database::getInfo(DATABASE_PATH, infoStorage);
        // Основной цикл создает экземпляр именованного канала, а затем ждет, пока клиент подключится к нему.
        // Когда клиент подключается, создается поток для обработки взаимодействия с этим клиентом,
        // и этот цикл (который основной) может ждать следующего запроса на подключение клиента. Это бесконечный цикл. 

            //cout << "Main thread waiting for connect on pipe " << "\\\\.\\pipe\\firstPipe" << endl;

            pipeClientToService = CreateNamedPipe(
                PIPE_CLIENT_TO_SERVICE_NAME,             // имя канала 
                PIPE_ACCESS_DUPLEX,       // чтение/запись доступ 
                PIPE_TYPE_MESSAGE |       // тип сообщения каналу 
                PIPE_READMODE_MESSAGE |   // режим чтения сообщений 
                PIPE_WAIT,                // режим блокирования
                PIPE_UNLIMITED_INSTANCES, // максимальное количество экземпляров 
                PIPE_BUFSIZE,                  // размер буфера на выход 
                PIPE_BUFSIZE,                  // размер буфера на вход 
                0,                        // клиент время 
                NULL);                    // атрибут безопасности по умолчанию 

            if (pipeClientToService == INVALID_HANDLE_VALUE)
            {
                return; //Создание именованного канала не удалось, код ошибки
            }

            // Exit if an error other than ERROR_PIPE_BUSY occurs.
            if (GetLastError() == ERROR_PIPE_BUSY)
            {
                CloseHandle(pipeClientToService);
                return;
            }

            if (GetLastError() == ERROR_BROKEN_PIPE)
            {
                CloseHandle(pipeClientToService);
                return;
            }

            if (GetLastError() == ERROR_FILE_NOT_FOUND)
            {
                CloseHandle(pipeClientToService);
                return;
            }
            // Подождите, пока клиент подключится; если это удастся,
            // функция возвращает ненулевое значение. Если функция
            // возвращает ноль, GetLastError возвращает ERROR_PIPE_CONNECTED.
            fConnected = ConnectNamedPipe(pipeClientToService, NULL) ?
                TRUE : (GetLastError() == ERROR_PIPE_CONNECTED);
            
            if (fConnected)
            {
                // Клиент подключён, создаётся поток для него...
                // Создание потока для клиента  
                //cout << "Client connected" << endl;
                std::this_thread::sleep_for(std::chrono::milliseconds(2));
                std::thread clientThread(&AntimalwareService::clientMessagesProcessing, this);
                clientThread.detach();
                std::this_thread::sleep_for(std::chrono::milliseconds(2));

                // Поток создан, получение и обработка сообщений...
            }
            else  // Клиент не смог подключиться, поэтому закрываем канал.
            {
                CloseHandle(pipeClientToService); //Создание потока не удалось, код ошибки
            }
       // }
        return;
	}
	 
	int AntimalwareService::DoStop()
	{
        Database outputInfo = Database(DATABASE_PATH, infoStorage);
		return 0;
	}

	AntimalwareServiceFactory::AntimalwareServiceFactory()
	{
	}

	std::unique_ptr<ServiceLib::ServiceManagement::Service> AntimalwareServiceFactory::Create()
	{
		return std::make_unique<AntimalwareService>();
	}

    int AntimalwareService::clientMessagesProcessing()
    {
        HANDLE tempPipeFirst = pipeClientToService;
        // Выполняем дополнительную проверку ошибок, поскольку
        // приложение будет продолжать работать, даже если этот
        // поток выходит из строя.
        if (tempPipeFirst == NULL)
        {
            return -1; //InstanceThread got an unexpected NULL value in lpvParam
        }

        pipeServiceToClient = CreateFile(
            PIPE_SERVICE_TO_CLIENT_NAME,   // pipe name 
            GENERIC_READ |  // read and write access 
            GENERIC_WRITE,
            0,              // no sharing 
            NULL,           // default security attributes
            OPEN_EXISTING,  // opens existing pipe 
            0,              // default attributes 
            NULL);          // no template file 
        HANDLE tempPipeSecond = pipeServiceToClient;
            // Break if the pipe handle is valid. 
        if (tempPipeSecond == INVALID_HANDLE_VALUE)
        {
            CloseHandle(tempPipeSecond);
            tempPipeSecond = NULL;
            return -1;
        }

        // Exit if an error other than ERROR_PIPE_BUSY occurs.
        if (GetLastError() == ERROR_PIPE_BUSY)
        {
            CloseHandle(tempPipeSecond);
            tempPipeSecond = NULL;
            return -1;
        }

        if (GetLastError() == ERROR_BROKEN_PIPE)
        {
            CloseHandle(tempPipeSecond);
            tempPipeSecond = NULL;
            return -1;
        }

        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            CloseHandle(tempPipeSecond);
            tempPipeSecond = NULL;
            return -1;
        }

        // Thread: Результат работы
        message threatsInfo;
        threatsInfo.cmd = COMMAND::INFO;
        threatsInfo.nArr.push_back(0);
        for (size_t i = 0; i < infoStorage->threatPaths.size(); i++)
        {
            threatsInfo.sArr.push_back(infoStorage->threatPaths.at(i));
            threatsInfo.sArr.push_back(infoStorage->threatNames.at(i));
        }
        Messenger::sendMessage(tempPipeSecond, PIPE_BUFSIZE, threatsInfo);
        threatsInfo.nArr.clear();
        threatsInfo.sArr.clear();

        threatsInfo.nArr.push_back(1);
        for (size_t i = 0; i < infoStorage->quarPaths.size(); i++)
        {
            threatsInfo.sArr.push_back(infoStorage->quarPaths.at(i));
            threatsInfo.sArr.push_back(infoStorage->quarNames.at(i));
        }
        Messenger::sendMessage(tempPipeSecond, PIPE_BUFSIZE, threatsInfo);
        threatsInfo.nArr.clear();
        threatsInfo.sArr.clear();


        listenPipe(tempPipeFirst, tempPipeSecond);

        // "Чистим" канал, чтобы клиент мог прочитать его содержимое
        // перед отключением. Затем отключаем канал и закрываем
        // дескриптор этого экземпляра канала.
        FlushFileBuffers(tempPipeFirst);
        DisconnectNamedPipe(tempPipeFirst);
        CloseHandle(tempPipeFirst);
        CloseHandle(tempPipeSecond);

        Database outputInfo = Database(DATABASE_PATH, infoStorage);
        //cout << "Thread поток завершил работу" << endl << endl;
        return 0;
    }

    void AntimalwareService::processingMessage(message newMessage, HANDLE tempPipeFirst, HANDLE tempPipeSecond)
    {
        Scanner scanner = Scanner(infoStorage);
        Monitoring monitoring = Monitoring(infoStorage);
        ScheduledScanner scheduledScanner = ScheduledScanner(infoStorage);
        FilesWorker filesWorker = FilesWorker(infoStorage);
        switch (newMessage.cmd)
        {
        case COMMAND::DEL: {
            filesWorker.deleteThreat(newMessage);
            break;
        }
        case COMMAND::START: {
            std::string filePath = newMessage.sArr.at(0);
            scanner.startScan(filePath, tempPipeSecond);
            break;
        }
        case COMMAND::STOP: {
            scanner.stopScan();
            break;
        }
        case COMMAND::MOVE_TO_QUARANTINE: {
            filesWorker.moveToQuarantine(newMessage);
            break;
        }
        case COMMAND::DELETE_FROM_QUARANTINE: {
            filesWorker.deleteFromQuarantine(newMessage);
            break;
        }
        case COMMAND::SET_SCHEDULE: {
            scheduledScanner.startScheduledScan(tempPipeSecond, newMessage);
            break;
        }
        case COMMAND::RESET_SCHEDULE: {
            scheduledScanner.cancelScheduledScan();
            break;
        }
        case COMMAND::SET_MONITORING: {
            std::string monitoringDirectory = newMessage.sArr.at(0);
            monitoring.start(monitoringDirectory, tempPipeSecond);
            break;
        }
        case COMMAND::STOP_MONITORING: {
            monitoring.stop();
            break;
        }
        case COMMAND::STOP_SERVICE: {
            FlushFileBuffers(tempPipeSecond);
            DisconnectNamedPipe(tempPipeSecond);
            CloseHandle(tempPipeSecond);          
            DoStop();
            ExitProcess(0);
            return;
        }
        }
        //cout << "Thread: Запрос клиента обработан" << endl << endl;
    }

    void AntimalwareService::listenPipe(HANDLE tempPipeFirst, HANDLE tempPipeSecond)
    {
        while (GetLastError() != ERROR_BROKEN_PIPE)
        {
            message newMessage = Messenger::readMessage(tempPipeFirst, PIPE_BUFSIZE);
            if (newMessage.cmd == COMMAND::UNKNOWN)
            {
                break;
            }

            //processingMessage(newMessage);
            std::thread scanThread(&AntimalwareService::processingMessage, this, newMessage, tempPipeFirst, tempPipeSecond);
            scanThread.detach();
        }
    }

}